<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意
识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿
来识别、拥抱和影响闭包的思维环境。

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。
<script>
    function foo() {
        var a = 2;

        function bar() {
            console.log(a);
        }

        return bar;
    }

    var baz = foo();
    baz(); // 2 —— 朋友，这就是闭包的效果。

    //函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作
    // 一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值

    /**
     * bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。
     *
     * 在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃
     圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很
     自然地会考虑对其进行回收。
     而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因
     没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。

     拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一
     直存活，以供 bar() 在之后任何时间进行引用。
     bar() 依然持有对该作用域的引用，而这个引用就叫作闭包
     * **/
</script>
</body>
</html>