<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
历史上,js一直没有模块(module)体系,无法将一个大程序拆分成互相依赖的小文件,再用简单的方法拼装起来

在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。
CommonJS 模块输出的是值的缓存，不存在动态更新

<body>
    <script>
        // CommonJS模块
        let {
            stat,
            exists,
            readFile
        } = require('fs');

        // 等同于
        let _fs = require('fs');
        let stat = _fs.stat;
        let exists = _fs.exists;
        let readfile = _fs.readfile;
    </script>
    上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。
    这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”


    ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。
    <script>
        // ES6模块
        import {
            stat,
            exists,
            readFile
        } from 'fs';
    </script>
    上面代码的实质是从fs模块加载 3 个方法，其他方法不加载
    这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6
    模块本身，因为它不是对象。

    ES6 模块还有以下好处。

    不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。
    将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。
    不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。
</body>

</html>